/***********************************************************
This procedure is generated by the query 51 template
in TPC-DS. This query is to compute the count of store sales 
resulting from promotions, the count of all store sales and 
their ratio for specific categories in a particular time 
zone and for a given year and month.
The detail steps for generating the procedure with loops
by transforming CTE query are as follows. CTE table
variable is :dms.
Then, for each scalar parameter that is used in the query
template, the loop, which calculates the query iteratively for
every range of parameter, is inserted. For the experiments
using the benchmark procedures, we created three databases
with different sizes: 10 GB, 50 GB, and 100 GB. Then, we
observed the scalability of the proposed algorithm using
these different database sizes. In addition, we show that the
performance of the algorithm varies according to the table
statistics, even for the same procedure.
***********************************************************/

drop procedure "TPC_DS_Q51";
call "TPC_DS_Q51"(1176);

create procedure "TPC_DS_Q51"(in dmsInfo integer)
as begin
declare dms integer;
dms := :dmsInfo; --1176

v1 = select ws_item_sk item_sk, ws_sales_price, ws_item_sk, ws_sold_date_sk from web_sales where ws_item_sk is not NULL ;
v2 = select ss_item_sk item_sk , ss_sold_date_sk, ss_item_sk, ss_sales_price from store_sales where ss_item_sk is not NULL ;

while (:dms < 1209) DO
web_v1 = select d_date, sum(sum(ws_sales_price)) over (partition by item_sk order by d_date rows between unbounded preceding and current row) cume_sales , item_sk
	     from :v1, date_dim where ws_sold_date_sk=d_date_sk and d_month_seq between :dms and :dms + 11 group by item_sk, d_date;


store_v1 = select d_date, sum(sum(ss_sales_price)) over (partition by ss_item_sk order by d_date rows between unbounded preceding and current row) cume_sales , item_sk
           from :v2 ,date_dim where ss_sold_date_sk=d_date_sk and d_month_seq between :dms and :dms + 11  group by ss_item_sk, d_date, item_sk;

v3 = select case when web.item_sk is not null then web.item_sk else store.item_sk end item_sk, case when web.d_date is not null then web.d_date else store.d_date end d_date, web.cume_sales web_sales, store.cume_sales store_sales 
     from :web_v1 web full outer join :store_v1 store on (web.item_sk = store.item_sk and web.d_date = store.d_date);
     
v4 = select item_sk ,d_date ,web_sales ,store_sales, max(web_sales) over (partition by item_sk order by d_date rows between unbounded preceding and current row) web_cumulative ,max(store_sales)
         over (partition by item_sk order by d_date rows between unbounded preceding and current row) store_cumulative
     from :v3;
select top 100 * from :v4 where web_cumulative > store_cumulative order by item_sk, d_date;

dms = :dms + 11;
end while;
end;
